= effectful-demo
Lance Gatlin <lance.gatlin@gmail.com>
v1,7 Jun 2016
:blogpost-status: unpublished
:blogpost-categories: s_mach, scala

== Overview
Note: ultimate goal of this library is only to demonstrate capability; it is an ongoing project.
* Declare pure service contracts ("effectful services") that accept a generic effect monad parameter
that can be any monad or nested monad stack (such as Future, Task, IO, writer, free, identity monad or any
logical combination like Task[Writer[A]])
* Each method's return value is wrapped in the generic monad type to ensure intended effects generated
by method call are captured by the monad
** Note: which effects are captured depends on the monad selected and the implementation of the service

Example: Declare a pure service for managing users
----
trait Users[E[_]] {
  def findByUsername(username: String) : E[Option[User]]
  def findById(id: UUID) : E[Option[User]]
  def findAll(start: Int, batchSize: Int) : E[Seq[User]]
  def create(id: UUID,username: String,plainTextPassword: String) : E[Boolean]
  def rename(userId: UUID, newUsername: String) : E[Boolean]
  def setPassword(userId: UUID, plainTextPassword: String) : E[Boolean]
  def remove(userId: UUID) : E[Boolean]
}
----

* Implement service trait with pure effect-free code, generically, for all monads and nested monads
* Use map/flatMap and for-comprehensions without the need for monad transformers or lifting
* Constructor inject service dependencies to hide from callers
* Defer effects to other services that capture the effects in the monad
* Use monad "augments" to ensure monad supports extra operations such as exception handling,
parallel execution or time delays

Example: Implment pure service for managing users
----
class UsersImpl[E[_]](
  usersDao: SqlDocDao[UUID,UserData,E],
  passwords: Passwords[E],
  logger: Logger[E]
)(implicit
  E:Monad[E]
) extends Users[E] {
  import ...

  def create(id: UUID, username: String, plainTextPassword: String) =
    findById(id).flatMap {
      case Some(_) => E.pure(false)
      case None =>
        findByUsername(username).flatMap {
          case Some(_) => E.pure(false)
          case None =>
            for {
              digest <- passwords.mkDigest(plainTextPassword)
              result <- usersDao.insert(id,UserData(
                username = username,
                passwordDigest = digest
              ))
              _ <- if(result) {
                info(s"Created user $id with username $username")
              } else {
                E.pure(())
              }
            } yield result
        }
    }
   ...
}
----

* Decide on a monad stack and wire and inject
* Lift services that are implemented with another monad (typically identity)
into the desired monad

Example: UserImpl with Future + LogWriter
----
  type E[A] = Future[LogWriter[A]]
...
  val passwords = new PasswordsImpl[E](
    passwordMismatchDelay = 5.seconds,
    logger = WriterLogger("passwords").liftService[E]
  )

  val userDao = new SqlDocDaoImpl[UUID,UsersImpl.UserData,E](
    sql = sqlDriver.liftService[E],
    recordMapping = userDataRecordMapping,
    metadataMapping = userDataMetadataRecordMapping
  )
  val users = new UsersImpl[E](
    usersDao = userDao,
    passwords = passwords,
    logger = WriterLogger("users").liftService[E]
  )
...
----

* Later, use a completely different monad without changing UserImpl

Example: UserLogins with identity monad instead
----
  type Id[A] = A
...
  val passwords = new PasswordsImpl[Id](
    passwordMismatchDelay = 5.seconds,
    logger = Slf4jLogger("passwords")
  )

  val userDao = new SqlDocDaoImpl[UUID,UsersImpl.UserData,Id](
    sql = sqlDriver,
    recordMapping = userDataRecordMapping,
    metadataMapping = userDataMetadataRecordMapping
  )
  val users = new UsersImpl[Id](
    usersDao = userDao,
    passwords = passwords,
    logger = Slf4jLogger("users")
  )
...
----

----

== Example: UserLogin with identity monad

----
$ sbt
[info] Loading project definition from /Users/lancegatlin/Code/effectful/project
[info] Set current project to effectful-demo (in build file:/Users/lancegatlin/Code/effectful/)
> test:console
[info] Updating {file:/Users/lancegatlin/Code/effectful/}effectful...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Compiling 2 Scala sources to /Users/lancegatlin/Code/effectful/target/scala-2.11/test-classes...
[info] Starting scala interpreter...
[info]
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).
Type in expressions for evaluation. Or try :help.

scala> import effectful.examples.IdExample._
import effectful.examples.IdExample._

scala> uuids.gen()
res0: effectful.Id[effectful.examples.pure.uuid.UUIDs.UUID] = f54214e6-2054-4717-b2bb-b0f9c0e7fbb1

scala> users.create(res0,"lance","password")
21:53:16.293 [MLog-Init-Reporter] INFO com.mchange.v2.log.MLog - MLog clients using slf4j logging.
...
21:53:16.736 [run-main-0] INFO users - Created user f54214e6-2054-4717-b2bb-b0f9c0e7fbb1 with username lance
res1: effectful.Id[Boolean] = true

scala> userLogins.login("lance","not my password")
21:53:30.595 [run-main-0] WARN passwords - Password mismatch delaying 5 seconds
21:53:35.600 [run-main-0] WARN userLogins - User f54214e6-2054-4717-b2bb-b0f9c0e7fbb1 password mismatch
res2: effectful.Id[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = -\/(PasswordMismatch)

scala> userLogins.login("lance","password")
21:53:45.645 [run-main-0] INFO tokens - Issued token 8a8055cd-04e6-4e06-bd17-7a2bebce192c to user f54214e6-2054-4717-b2bb-b0f9c0e7fbb1
21:53:45.646 [run-main-0] INFO userLogins - User f54214e6-2054-4717-b2bb-b0f9c0e7fbb1 logged in, issued token 8a8055cd-04e6-4e06-bd17-7a2bebce192c
res3: effectful.Id[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = \/-(8a8055cd-04e6-4e06-bd17-7a2bebce192c)

scala> users.findbyId(res0)
<console>:16: error: value findbyId is not a member of effectful.examples.pure.user.impl.UsersImpl[effectful.Id]
       users.findbyId(res0)
             ^

scala> users.findById(res0)
res5: effectful.Id[Option[effectful.examples.pure.user.Users.User]] = Some(User(f54214e6-2054-4717-b2bb-b0f9c0e7fbb1,lance,w+diya9sU07ZEVMRFk4QIG0qoTKUiKuV,2016-06-08T01:53:07.661Z,None))

scala>
----

== Example: UserLogin with Future + LogWriter

----
$ sbt
[info] Loading project definition from /Users/lancegatlin/Code/effectful/project
[info] Set current project to effectful-demo (in build file:/Users/lancegatlin/Code/effectful/)
> test:console
[info] Starting scala interpreter...
[info]
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).
Type in expressions for evaluation. Or try :help.

scala> import scala.concurrent._
import scala.concurrent._

scala> import scala.concurrent.duration._
import scala.concurrent.duration._

scala> import effectful.examples.FutureLogWriterExample._
import effectful.examples.FutureLogWriterExample._

scala> uuids.gen()
res0: effectful.Id[effectful.examples.pure.uuid.UUIDs.UUID] = 6cff63f8-1294-4e1a-9943-f7c5b5598f3d

scala> users.create(res0,"lance","password")
res1: effectful.examples.FutureLogWriterExample.E[Boolean] = List()

scala> 21:57:51.026 [MLog-Init-Reporter] INFO com.mchange.v2.log.MLog - MLog clients using slf4j logging.
...
Verified test user is inserted...

scala> Await.result(res1,Duration.Inf)
res2: effectful.examples.adapter.scalaz.writer.LogWriter[Boolean] = WriterT((List(LogEntry(users,Info,Created user 6cff63f8-1294-4e1a-9943-f7c5b5598f3d with username lance,None,2016-06-08T01:57:51.943Z)),true))

scala> userLogins.login("lance","not my password")
res3: effectful.examples.FutureLogWriterExample.E[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = List()

scala> Await.result(res3,Duration.Inf)
res4: effectful.examples.adapter.scalaz.writer.LogWriter[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = WriterT((List(LogEntry(passwords,Warn,Password mismatch delaying 5 seconds,None,2016-06-08T01:59:14.130Z), LogEntry(userLogins,Warn,User 6cff63f8-1294-4e1a-9943-f7c5b5598f3d password mismatch,None,2016-06-08T01:59:19.146Z)),-\/(PasswordMismatch)))

scala> userLogins.login("lance","password")
res5: effectful.examples.FutureLogWriterExample.E[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = List()

scala> Await.result(res6,Duration.Inf)
res6: effectful.examples.adapter.scalaz.writer.LogWriter[scalaz.\/[effectful.examples.pure.user.UserLogins.LoginFailure,effectful.examples.pure.user.UserLogins.Token]] = WriterT((List(LogEntry(tokens,Info,Issued token 273a4ec0-571c-4cfe-93c2-53198717a6b6 to user 6cff63f8-1294-4e1a-9943-f7c5b5598f3d,None,2016-06-08T01:59:37.725Z), LogEntry(userLogins,Info,User 6cff63f8-1294-4e1a-9943-f7c5b5598f3d logged in, issued token 273a4ec0-571c-4cfe-93c2-53198717a6b6,None,2016-06-08T01:59:37.725Z)),\/-(273a4ec0-571c-4cfe-93c2-53198717a6b6)))

scala>
----

== Example: UserLogin with Free monad

